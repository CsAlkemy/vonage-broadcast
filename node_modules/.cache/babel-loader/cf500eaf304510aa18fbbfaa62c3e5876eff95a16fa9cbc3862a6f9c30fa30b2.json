{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\n/* global OT */\n\n/** Dependencies */\nvar _require = require('./errors'),\n  CoreError = _require.CoreError;\nvar _require2 = require('./util'),\n  dom = _require2.dom,\n  path = _require2.path,\n  pathOr = _require2.pathOr,\n  properCase = _require2.properCase;\nvar _require3 = require('./logging'),\n  message = _require3.message,\n  logAction = _require3.logAction,\n  logVariation = _require3.logVariation;\n\n/**\n * Default UI propties\n * https://tokbox.com/developer/guides/customize-ui/js/\n */\n\nvar defaultCallProperties = {\n  insertMode: 'append',\n  width: '100%',\n  height: '100%',\n  showControls: false,\n  style: {\n    buttonDisplayMode: 'off'\n  }\n};\nvar Communication = function Communication(options) {\n  _classCallCheck(this, Communication);\n  _initialiseProps.call(this);\n  this.validateOptions(options);\n  this.setSession();\n  this.createEventListeners();\n}\n/**\n * Trigger an event through the API layer\n * @param {String} event - The name of the event\n * @param {*} [data]\n */\n\n/**\n * Determine whether or not the party is able to join the call based on\n * the specified connection limit, if any.\n * @return {Boolean}\n */\n\n/**\n * Create a camera publisher object\n * @param {Object} publisherProperties\n * @returns {Promise} <resolve: Object, reject: Error>\n */\n\n/**\n * Publish the local camera stream and update state\n * @param {Object} publisherProperties\n * @returns {Promise} <resolve: empty, reject: Error>\n */\n\n/**\n * Subscribe to a stream and update the state\n * @param {Object} stream - An OpenTok stream object\n * @param {Object} [subsriberOptions]\n * @param {Boolean} [networkTest] - Are we subscribing to our own publisher for a network test?\n * @returns {Promise} <resolve: Object, reject: Error >\n */\n\n/**\n * Unsubscribe from a stream and update the state\n * @param {Object} subscriber - An OpenTok subscriber object\n * @returns {Promise} <resolve: empty>\n */\n\n/**\n * Set session in module scope\n */\n\n/**\n * Subscribe to new stream unless autoSubscribe is set to false\n * @param {Object} stream\n */\n\n/**\n * Update state and trigger corresponding event(s) when stream is destroyed\n * @param {Object} stream\n */\n\n/**\n * Listen for API-level events\n */\n\n/**\n * Start publishing the local camera feed and subscribing to streams in the session\n * @param {Object} publisherProperties\n * @returns {Promise} <resolve: Object, reject: Error>\n */\n\n/**\n * Stop publishing and unsubscribe from all streams\n */\n\n/**\n * Enable/disable local audio or video\n * @param {String} source - 'audio' or 'video'\n * @param {Boolean} enable\n */\n\n/**\n * Enable/disable remote audio or video\n * @param {String} subscriberId\n * @param {String} source - 'audio' or 'video'\n * @param {Boolean} enable\n */;\nvar _initialiseProps = function _initialiseProps() {\n  var _this = this;\n  Object.defineProperty(this, 'validateOptions', {\n    enumerable: true,\n    writable: true,\n    value: function value(options) {\n      var requiredOptions = ['core', 'state', 'analytics'];\n      requiredOptions.forEach(function (option) {\n        if (!options[option]) {\n          throw new CoreError(option + ' is a required option.', 'invalidParameters');\n        }\n      });\n      var callProperties = options.callProperties,\n        screenProperties = options.screenProperties,\n        autoSubscribe = options.autoSubscribe,\n        subscribeOnly = options.subscribeOnly;\n      _this.active = false;\n      _this.core = options.core;\n      _this.state = options.state;\n      _this.analytics = options.analytics;\n      _this.streamContainers = options.streamContainers;\n      _this.callProperties = Object.assign({}, defaultCallProperties, callProperties);\n      _this.connectionLimit = options.connectionLimit || null;\n      _this.autoSubscribe = options.hasOwnProperty('autoSubscribe') ? autoSubscribe : true;\n      _this.subscribeOnly = options.hasOwnProperty('subscribeOnly') ? subscribeOnly : false;\n      _this.screenProperties = Object.assign({}, defaultCallProperties, {\n        videoSource: 'window'\n      }, screenProperties);\n    }\n  });\n  Object.defineProperty(this, 'triggerEvent', {\n    enumerable: true,\n    writable: true,\n    value: function value(event, data) {\n      return _this.core.triggerEvent(event, data);\n    }\n  });\n  Object.defineProperty(this, 'ableToJoin', {\n    enumerable: true,\n    writable: true,\n    value: function value() {\n      var connectionLimit = _this.connectionLimit,\n        state = _this.state;\n      if (!connectionLimit) {\n        return true;\n      }\n      // Not using the session here since we're concerned with number of active publishers\n      var connections = Object.values(state.getStreams()).filter(function (s) {\n        return s.videoType === 'camera';\n      });\n      return connections.length < connectionLimit;\n    }\n  });\n  Object.defineProperty(this, 'createPublisher', {\n    enumerable: true,\n    writable: true,\n    value: function value(publisherProperties) {\n      var callProperties = _this.callProperties,\n        streamContainers = _this.streamContainers;\n      return new Promise(function (resolve, reject) {\n        // TODO: Handle adding 'name' option to props\n        var props = Object.assign({}, callProperties, publisherProperties);\n        // TODO: Figure out how to handle common vs package-specific options\n        // ^^^ This may already be available through package options\n        var container = dom.element(streamContainers('publisher', 'camera'));\n        var publisher = OT.initPublisher(container, props, function (error) {\n          error ? reject(error) : resolve(publisher);\n        });\n      });\n    }\n  });\n  Object.defineProperty(this, 'publish', {\n    enumerable: true,\n    writable: true,\n    value: function value(publisherProperties) {\n      var analytics = _this.analytics,\n        state = _this.state,\n        createPublisher = _this.createPublisher,\n        session = _this.session,\n        triggerEvent = _this.triggerEvent,\n        subscribeOnly = _this.subscribeOnly;\n\n      /**\n       * For subscriber tokens or cases where we just don't want to be seen or heard.\n       */\n\n      if (subscribeOnly) {\n        message('Instance is configured with subscribeOnly set to true. Cannot publish to session');\n        return Promise.resolve();\n      }\n      return new Promise(function (resolve, reject) {\n        var onPublish = function onPublish(publisher) {\n          return function (error) {\n            if (error) {\n              reject(error);\n              analytics.log(logAction.startCall, logVariation.fail);\n            } else {\n              analytics.log(logAction.startCall, logVariation.success);\n              state.addPublisher('camera', publisher);\n              resolve(publisher);\n            }\n          };\n        };\n        var publishToSession = function publishToSession(publisher) {\n          return session.publish(publisher, onPublish(publisher));\n        };\n        var handleError = function handleError(error) {\n          analytics.log(logAction.startCall, logVariation.fail);\n          var errorMessage = error.code === 1010 ? 'Check your network connection' : error.message;\n          triggerEvent('error', errorMessage);\n          reject(error);\n        };\n        createPublisher(publisherProperties).then(publishToSession).catch(handleError);\n      });\n    }\n  });\n  Object.defineProperty(this, 'subscribe', {\n    enumerable: true,\n    writable: true,\n    value: function value(stream) {\n      var subscriberProperties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var networkTest = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var analytics = _this.analytics,\n        state = _this.state,\n        streamContainers = _this.streamContainers,\n        session = _this.session,\n        triggerEvent = _this.triggerEvent,\n        callProperties = _this.callProperties,\n        screenProperties = _this.screenProperties;\n      return new Promise(function (resolve, reject) {\n        var connectionData = void 0;\n        analytics.log(logAction.subscribe, logVariation.attempt);\n        var streamMap = state.getStreamMap();\n        var streamId = stream.streamId;\n        // No videoType indicates SIP https://tokbox.com/developer/guides/sip/\n\n        var type = pathOr('sip', 'videoType', stream);\n        if (streamMap[streamId] && !networkTest) {\n          // Are we already subscribing to the stream?\n          var _state$all = state.all(),\n            subscribers = _state$all.subscribers;\n          resolve(subscribers[type][streamMap[streamId]]);\n        } else {\n          try {\n            connectionData = JSON.parse(path(['connection', 'data'], stream) || null);\n          } catch (e) {\n            connectionData = path(['connection', 'data'], stream);\n          }\n          var container = dom.element(streamContainers('subscriber', type, connectionData, stream));\n          var options = Object.assign({}, type === 'camera' || type === 'sip' ? callProperties : screenProperties, subscriberProperties);\n          var subscriber = session.subscribe(stream, container, options, function (error) {\n            if (error) {\n              analytics.log(logAction.subscribe, logVariation.fail);\n              reject(error);\n            } else {\n              state.addSubscriber(subscriber);\n              triggerEvent('subscribeTo' + properCase(type), Object.assign({}, {\n                subscriber: subscriber\n              }, state.all()));\n              type === 'screen' && triggerEvent('startViewingSharedScreen', subscriber); // Legacy event\n              analytics.log(logAction.subscribe, logVariation.success);\n              resolve(subscriber);\n            }\n          });\n        }\n      });\n    }\n  });\n  Object.defineProperty(this, 'unsubscribe', {\n    enumerable: true,\n    writable: true,\n    value: function value(subscriber) {\n      var analytics = _this.analytics,\n        session = _this.session,\n        state = _this.state;\n      return new Promise(function (resolve) {\n        analytics.log(logAction.unsubscribe, logVariation.attempt);\n        var type = pathOr('sip', 'stream.videoType', subscriber);\n        state.removeSubscriber(type, subscriber);\n        session.unsubscribe(subscriber);\n        analytics.log(logAction.unsubscribe, logVariation.success);\n        resolve();\n      });\n    }\n  });\n  Object.defineProperty(this, 'setSession', {\n    enumerable: true,\n    writable: true,\n    value: function value() {\n      _this.session = _this.state.getSession();\n    }\n  });\n  Object.defineProperty(this, 'onStreamCreated', {\n    enumerable: true,\n    writable: true,\n    value: function value(_ref) {\n      var stream = _ref.stream;\n      return _this.active && _this.autoSubscribe && _this.subscribe(stream);\n    }\n  });\n  Object.defineProperty(this, 'onStreamDestroyed', {\n    enumerable: true,\n    writable: true,\n    value: function value(_ref2) {\n      var stream = _ref2.stream;\n      var state = _this.state,\n        triggerEvent = _this.triggerEvent;\n      state.removeStream(stream);\n      var type = pathOr('sip', 'videoType', stream);\n      type === 'screen' && triggerEvent('endViewingSharedScreen'); // Legacy event\n      triggerEvent('unsubscribeFrom' + properCase(type), state.getPubSub());\n    }\n  });\n  Object.defineProperty(this, 'createEventListeners', {\n    enumerable: true,\n    writable: true,\n    value: function value() {\n      var core = _this.core,\n        onStreamCreated = _this.onStreamCreated,\n        onStreamDestroyed = _this.onStreamDestroyed;\n      core.on('streamCreated', onStreamCreated);\n      core.on('streamDestroyed', onStreamDestroyed);\n    }\n  });\n  Object.defineProperty(this, 'startCall', {\n    enumerable: true,\n    writable: true,\n    value: function value(publisherProperties) {\n      var analytics = _this.analytics,\n        state = _this.state,\n        subscribe = _this.subscribe,\n        ableToJoin = _this.ableToJoin,\n        triggerEvent = _this.triggerEvent,\n        autoSubscribe = _this.autoSubscribe,\n        publish = _this.publish;\n      return new Promise(function (resolve, reject) {\n        // eslint-disable-line consistent-return\n        analytics.log(logAction.startCall, logVariation.attempt);\n        _this.active = true;\n        var initialStreamIds = Object.keys(state.getStreams());\n\n        /**\n         * Determine if we're able to join the session based on an existing connection limit\n         */\n        if (!ableToJoin()) {\n          var errorMessage = 'Session has reached its connection limit';\n          triggerEvent('error', errorMessage);\n          analytics.log(logAction.startCall, logVariation.fail);\n          return reject(new CoreError(errorMessage, 'connectionLimit'));\n        }\n\n        /**\n         * Subscribe to any streams that existed before we start the call from our side.\n         */\n        var subscribeToInitialStreams = function subscribeToInitialStreams(publisher) {\n          // Get an array of initial subscription promises\n          var initialSubscriptions = function initialSubscriptions() {\n            if (autoSubscribe) {\n              var streams = state.getStreams();\n              return initialStreamIds.map(function (id) {\n                return subscribe(streams[id]);\n              });\n            }\n            return [Promise.resolve()];\n          };\n\n          // Handle success\n          var onSubscribeToAll = function onSubscribeToAll() {\n            var pubSubData = Object.assign({}, state.getPubSub(), {\n              publisher: publisher\n            });\n            triggerEvent('startCall', pubSubData);\n            resolve(pubSubData);\n          };\n\n          // Handle error\n          var onError = function onError(reason) {\n            message('Failed to subscribe to all existing streams: ' + reason);\n            // We do not reject here in case we still successfully publish to the session\n            resolve(Object.assign({}, _this.state.getPubSub(), {\n              publisher: publisher\n            }));\n          };\n          Promise.all(initialSubscriptions()).then(onSubscribeToAll).catch(onError);\n        };\n        publish(publisherProperties).then(subscribeToInitialStreams).catch(reject);\n      });\n    }\n  });\n  Object.defineProperty(this, 'endCall', {\n    enumerable: true,\n    writable: true,\n    value: function value() {\n      var analytics = _this.analytics,\n        state = _this.state,\n        session = _this.session,\n        unsubscribe = _this.unsubscribe,\n        triggerEvent = _this.triggerEvent;\n      analytics.log(logAction.endCall, logVariation.attempt);\n      var _state$getPubSub = state.getPubSub(),\n        publishers = _state$getPubSub.publishers,\n        subscribers = _state$getPubSub.subscribers;\n      var unpublish = function unpublish(publisher) {\n        return session.unpublish(publisher);\n      };\n      Object.values(publishers.camera).forEach(unpublish);\n      Object.values(publishers.screen).forEach(unpublish);\n      // TODO Promise.all for unsubsribing\n      Object.values(subscribers.camera).forEach(unsubscribe);\n      Object.values(subscribers.screen).forEach(unsubscribe);\n      state.removeAllPublishers();\n      _this.active = false;\n      triggerEvent('endCall');\n      analytics.log(logAction.endCall, logVariation.success);\n    }\n  });\n  Object.defineProperty(this, 'enableLocalAV', {\n    enumerable: true,\n    writable: true,\n    value: function value(id, source, enable) {\n      var method = 'publish' + properCase(source);\n      var _state$getPubSub2 = _this.state.getPubSub(),\n        publishers = _state$getPubSub2.publishers;\n      publishers.camera[id][method](enable);\n    }\n  });\n  Object.defineProperty(this, 'enableRemoteAV', {\n    enumerable: true,\n    writable: true,\n    value: function value(subscriberId, source, enable) {\n      var method = 'subscribeTo' + properCase(source);\n      var _state$getPubSub3 = _this.state.getPubSub(),\n        subscribers = _state$getPubSub3.subscribers;\n      var subscriber = subscribers.camera[subscriberId] || subscribers.sip[subscriberId];\n      subscriber[method](enable);\n    }\n  });\n};\nexports.default = Communication;","map":{"version":3,"names":["Object","defineProperty","exports","value","_classCallCheck","instance","Constructor","TypeError","_require","require","CoreError","_require2","dom","path","pathOr","properCase","_require3","message","logAction","logVariation","defaultCallProperties","insertMode","width","height","showControls","style","buttonDisplayMode","Communication","options","_initialiseProps","call","validateOptions","setSession","createEventListeners","_this","enumerable","writable","requiredOptions","forEach","option","callProperties","screenProperties","autoSubscribe","subscribeOnly","active","core","state","analytics","streamContainers","assign","connectionLimit","hasOwnProperty","videoSource","event","data","triggerEvent","connections","values","getStreams","filter","s","videoType","length","publisherProperties","Promise","resolve","reject","props","container","element","publisher","OT","initPublisher","error","createPublisher","session","onPublish","log","startCall","fail","success","addPublisher","publishToSession","publish","handleError","errorMessage","code","then","catch","stream","subscriberProperties","arguments","undefined","networkTest","connectionData","subscribe","attempt","streamMap","getStreamMap","streamId","type","_state$all","all","subscribers","JSON","parse","e","subscriber","addSubscriber","unsubscribe","removeSubscriber","getSession","_ref","_ref2","removeStream","getPubSub","onStreamCreated","onStreamDestroyed","on","ableToJoin","initialStreamIds","keys","subscribeToInitialStreams","initialSubscriptions","streams","map","id","onSubscribeToAll","pubSubData","onError","reason","endCall","_state$getPubSub","publishers","unpublish","camera","screen","removeAllPublishers","source","enable","method","_state$getPubSub2","subscriberId","_state$getPubSub3","sip","default"],"sources":["/home/awolf/WebstormProjects/accelerator-sample-apps-js/react-sample-app/node_modules/opentok-accelerator-core/dist/communication.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* global OT */\n\n/** Dependencies */\nvar _require = require('./errors'),\n    CoreError = _require.CoreError;\n\nvar _require2 = require('./util'),\n    dom = _require2.dom,\n    path = _require2.path,\n    pathOr = _require2.pathOr,\n    properCase = _require2.properCase;\n\nvar _require3 = require('./logging'),\n    message = _require3.message,\n    logAction = _require3.logAction,\n    logVariation = _require3.logVariation;\n\n/**\n * Default UI propties\n * https://tokbox.com/developer/guides/customize-ui/js/\n */\n\n\nvar defaultCallProperties = {\n  insertMode: 'append',\n  width: '100%',\n  height: '100%',\n  showControls: false,\n  style: {\n    buttonDisplayMode: 'off'\n  }\n};\n\nvar Communication = function Communication(options) {\n  _classCallCheck(this, Communication);\n\n  _initialiseProps.call(this);\n\n  this.validateOptions(options);\n  this.setSession();\n  this.createEventListeners();\n}\n/**\n * Trigger an event through the API layer\n * @param {String} event - The name of the event\n * @param {*} [data]\n */\n\n\n/**\n * Determine whether or not the party is able to join the call based on\n * the specified connection limit, if any.\n * @return {Boolean}\n */\n\n\n/**\n * Create a camera publisher object\n * @param {Object} publisherProperties\n * @returns {Promise} <resolve: Object, reject: Error>\n */\n\n\n/**\n * Publish the local camera stream and update state\n * @param {Object} publisherProperties\n * @returns {Promise} <resolve: empty, reject: Error>\n */\n\n\n/**\n * Subscribe to a stream and update the state\n * @param {Object} stream - An OpenTok stream object\n * @param {Object} [subsriberOptions]\n * @param {Boolean} [networkTest] - Are we subscribing to our own publisher for a network test?\n * @returns {Promise} <resolve: Object, reject: Error >\n */\n\n\n/**\n * Unsubscribe from a stream and update the state\n * @param {Object} subscriber - An OpenTok subscriber object\n * @returns {Promise} <resolve: empty>\n */\n\n\n/**\n * Set session in module scope\n */\n\n\n/**\n * Subscribe to new stream unless autoSubscribe is set to false\n * @param {Object} stream\n */\n\n\n/**\n * Update state and trigger corresponding event(s) when stream is destroyed\n * @param {Object} stream\n */\n\n\n/**\n * Listen for API-level events\n */\n\n\n/**\n * Start publishing the local camera feed and subscribing to streams in the session\n * @param {Object} publisherProperties\n * @returns {Promise} <resolve: Object, reject: Error>\n */\n\n\n/**\n * Stop publishing and unsubscribe from all streams\n */\n\n\n/**\n * Enable/disable local audio or video\n * @param {String} source - 'audio' or 'video'\n * @param {Boolean} enable\n */\n\n\n/**\n * Enable/disable remote audio or video\n * @param {String} subscriberId\n * @param {String} source - 'audio' or 'video'\n * @param {Boolean} enable\n */\n;\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this = this;\n\n  Object.defineProperty(this, 'validateOptions', {\n    enumerable: true,\n    writable: true,\n    value: function value(options) {\n      var requiredOptions = ['core', 'state', 'analytics'];\n      requiredOptions.forEach(function (option) {\n        if (!options[option]) {\n          throw new CoreError(option + ' is a required option.', 'invalidParameters');\n        }\n      });\n      var callProperties = options.callProperties,\n          screenProperties = options.screenProperties,\n          autoSubscribe = options.autoSubscribe,\n          subscribeOnly = options.subscribeOnly;\n\n      _this.active = false;\n      _this.core = options.core;\n      _this.state = options.state;\n      _this.analytics = options.analytics;\n      _this.streamContainers = options.streamContainers;\n      _this.callProperties = Object.assign({}, defaultCallProperties, callProperties);\n      _this.connectionLimit = options.connectionLimit || null;\n      _this.autoSubscribe = options.hasOwnProperty('autoSubscribe') ? autoSubscribe : true;\n      _this.subscribeOnly = options.hasOwnProperty('subscribeOnly') ? subscribeOnly : false;\n      _this.screenProperties = Object.assign({}, defaultCallProperties, { videoSource: 'window' }, screenProperties);\n    }\n  });\n  Object.defineProperty(this, 'triggerEvent', {\n    enumerable: true,\n    writable: true,\n    value: function value(event, data) {\n      return _this.core.triggerEvent(event, data);\n    }\n  });\n  Object.defineProperty(this, 'ableToJoin', {\n    enumerable: true,\n    writable: true,\n    value: function value() {\n      var connectionLimit = _this.connectionLimit,\n          state = _this.state;\n\n      if (!connectionLimit) {\n        return true;\n      }\n      // Not using the session here since we're concerned with number of active publishers\n      var connections = Object.values(state.getStreams()).filter(function (s) {\n        return s.videoType === 'camera';\n      });\n      return connections.length < connectionLimit;\n    }\n  });\n  Object.defineProperty(this, 'createPublisher', {\n    enumerable: true,\n    writable: true,\n    value: function value(publisherProperties) {\n      var callProperties = _this.callProperties,\n          streamContainers = _this.streamContainers;\n\n      return new Promise(function (resolve, reject) {\n        // TODO: Handle adding 'name' option to props\n        var props = Object.assign({}, callProperties, publisherProperties);\n        // TODO: Figure out how to handle common vs package-specific options\n        // ^^^ This may already be available through package options\n        var container = dom.element(streamContainers('publisher', 'camera'));\n        var publisher = OT.initPublisher(container, props, function (error) {\n          error ? reject(error) : resolve(publisher);\n        });\n      });\n    }\n  });\n  Object.defineProperty(this, 'publish', {\n    enumerable: true,\n    writable: true,\n    value: function value(publisherProperties) {\n      var analytics = _this.analytics,\n          state = _this.state,\n          createPublisher = _this.createPublisher,\n          session = _this.session,\n          triggerEvent = _this.triggerEvent,\n          subscribeOnly = _this.subscribeOnly;\n\n      /**\n       * For subscriber tokens or cases where we just don't want to be seen or heard.\n       */\n\n      if (subscribeOnly) {\n        message('Instance is configured with subscribeOnly set to true. Cannot publish to session');\n        return Promise.resolve();\n      }\n\n      return new Promise(function (resolve, reject) {\n        var onPublish = function onPublish(publisher) {\n          return function (error) {\n            if (error) {\n              reject(error);\n              analytics.log(logAction.startCall, logVariation.fail);\n            } else {\n              analytics.log(logAction.startCall, logVariation.success);\n              state.addPublisher('camera', publisher);\n              resolve(publisher);\n            }\n          };\n        };\n\n        var publishToSession = function publishToSession(publisher) {\n          return session.publish(publisher, onPublish(publisher));\n        };\n\n        var handleError = function handleError(error) {\n          analytics.log(logAction.startCall, logVariation.fail);\n          var errorMessage = error.code === 1010 ? 'Check your network connection' : error.message;\n          triggerEvent('error', errorMessage);\n          reject(error);\n        };\n\n        createPublisher(publisherProperties).then(publishToSession).catch(handleError);\n      });\n    }\n  });\n  Object.defineProperty(this, 'subscribe', {\n    enumerable: true,\n    writable: true,\n    value: function value(stream) {\n      var subscriberProperties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var networkTest = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var analytics = _this.analytics,\n          state = _this.state,\n          streamContainers = _this.streamContainers,\n          session = _this.session,\n          triggerEvent = _this.triggerEvent,\n          callProperties = _this.callProperties,\n          screenProperties = _this.screenProperties;\n\n      return new Promise(function (resolve, reject) {\n        var connectionData = void 0;\n        analytics.log(logAction.subscribe, logVariation.attempt);\n        var streamMap = state.getStreamMap();\n        var streamId = stream.streamId;\n        // No videoType indicates SIP https://tokbox.com/developer/guides/sip/\n\n        var type = pathOr('sip', 'videoType', stream);\n        if (streamMap[streamId] && !networkTest) {\n          // Are we already subscribing to the stream?\n          var _state$all = state.all(),\n              subscribers = _state$all.subscribers;\n\n          resolve(subscribers[type][streamMap[streamId]]);\n        } else {\n          try {\n            connectionData = JSON.parse(path(['connection', 'data'], stream) || null);\n          } catch (e) {\n            connectionData = path(['connection', 'data'], stream);\n          }\n          var container = dom.element(streamContainers('subscriber', type, connectionData, stream));\n          var options = Object.assign({}, type === 'camera' || type === 'sip' ? callProperties : screenProperties, subscriberProperties);\n          var subscriber = session.subscribe(stream, container, options, function (error) {\n            if (error) {\n              analytics.log(logAction.subscribe, logVariation.fail);\n              reject(error);\n            } else {\n              state.addSubscriber(subscriber);\n              triggerEvent('subscribeTo' + properCase(type), Object.assign({}, { subscriber: subscriber }, state.all()));\n              type === 'screen' && triggerEvent('startViewingSharedScreen', subscriber); // Legacy event\n              analytics.log(logAction.subscribe, logVariation.success);\n              resolve(subscriber);\n            }\n          });\n        }\n      });\n    }\n  });\n  Object.defineProperty(this, 'unsubscribe', {\n    enumerable: true,\n    writable: true,\n    value: function value(subscriber) {\n      var analytics = _this.analytics,\n          session = _this.session,\n          state = _this.state;\n\n      return new Promise(function (resolve) {\n        analytics.log(logAction.unsubscribe, logVariation.attempt);\n        var type = pathOr('sip', 'stream.videoType', subscriber);\n        state.removeSubscriber(type, subscriber);\n        session.unsubscribe(subscriber);\n        analytics.log(logAction.unsubscribe, logVariation.success);\n        resolve();\n      });\n    }\n  });\n  Object.defineProperty(this, 'setSession', {\n    enumerable: true,\n    writable: true,\n    value: function value() {\n      _this.session = _this.state.getSession();\n    }\n  });\n  Object.defineProperty(this, 'onStreamCreated', {\n    enumerable: true,\n    writable: true,\n    value: function value(_ref) {\n      var stream = _ref.stream;\n      return _this.active && _this.autoSubscribe && _this.subscribe(stream);\n    }\n  });\n  Object.defineProperty(this, 'onStreamDestroyed', {\n    enumerable: true,\n    writable: true,\n    value: function value(_ref2) {\n      var stream = _ref2.stream;\n      var state = _this.state,\n          triggerEvent = _this.triggerEvent;\n\n      state.removeStream(stream);\n      var type = pathOr('sip', 'videoType', stream);\n      type === 'screen' && triggerEvent('endViewingSharedScreen'); // Legacy event\n      triggerEvent('unsubscribeFrom' + properCase(type), state.getPubSub());\n    }\n  });\n  Object.defineProperty(this, 'createEventListeners', {\n    enumerable: true,\n    writable: true,\n    value: function value() {\n      var core = _this.core,\n          onStreamCreated = _this.onStreamCreated,\n          onStreamDestroyed = _this.onStreamDestroyed;\n\n      core.on('streamCreated', onStreamCreated);\n      core.on('streamDestroyed', onStreamDestroyed);\n    }\n  });\n  Object.defineProperty(this, 'startCall', {\n    enumerable: true,\n    writable: true,\n    value: function value(publisherProperties) {\n      var analytics = _this.analytics,\n          state = _this.state,\n          subscribe = _this.subscribe,\n          ableToJoin = _this.ableToJoin,\n          triggerEvent = _this.triggerEvent,\n          autoSubscribe = _this.autoSubscribe,\n          publish = _this.publish;\n\n      return new Promise(function (resolve, reject) {\n        // eslint-disable-line consistent-return\n        analytics.log(logAction.startCall, logVariation.attempt);\n\n        _this.active = true;\n        var initialStreamIds = Object.keys(state.getStreams());\n\n        /**\n         * Determine if we're able to join the session based on an existing connection limit\n         */\n        if (!ableToJoin()) {\n          var errorMessage = 'Session has reached its connection limit';\n          triggerEvent('error', errorMessage);\n          analytics.log(logAction.startCall, logVariation.fail);\n          return reject(new CoreError(errorMessage, 'connectionLimit'));\n        }\n\n        /**\n         * Subscribe to any streams that existed before we start the call from our side.\n         */\n        var subscribeToInitialStreams = function subscribeToInitialStreams(publisher) {\n          // Get an array of initial subscription promises\n          var initialSubscriptions = function initialSubscriptions() {\n            if (autoSubscribe) {\n              var streams = state.getStreams();\n              return initialStreamIds.map(function (id) {\n                return subscribe(streams[id]);\n              });\n            }\n            return [Promise.resolve()];\n          };\n\n          // Handle success\n          var onSubscribeToAll = function onSubscribeToAll() {\n            var pubSubData = Object.assign({}, state.getPubSub(), { publisher: publisher });\n            triggerEvent('startCall', pubSubData);\n            resolve(pubSubData);\n          };\n\n          // Handle error\n          var onError = function onError(reason) {\n            message('Failed to subscribe to all existing streams: ' + reason);\n            // We do not reject here in case we still successfully publish to the session\n            resolve(Object.assign({}, _this.state.getPubSub(), { publisher: publisher }));\n          };\n\n          Promise.all(initialSubscriptions()).then(onSubscribeToAll).catch(onError);\n        };\n\n        publish(publisherProperties).then(subscribeToInitialStreams).catch(reject);\n      });\n    }\n  });\n  Object.defineProperty(this, 'endCall', {\n    enumerable: true,\n    writable: true,\n    value: function value() {\n      var analytics = _this.analytics,\n          state = _this.state,\n          session = _this.session,\n          unsubscribe = _this.unsubscribe,\n          triggerEvent = _this.triggerEvent;\n\n      analytics.log(logAction.endCall, logVariation.attempt);\n\n      var _state$getPubSub = state.getPubSub(),\n          publishers = _state$getPubSub.publishers,\n          subscribers = _state$getPubSub.subscribers;\n\n      var unpublish = function unpublish(publisher) {\n        return session.unpublish(publisher);\n      };\n      Object.values(publishers.camera).forEach(unpublish);\n      Object.values(publishers.screen).forEach(unpublish);\n      // TODO Promise.all for unsubsribing\n      Object.values(subscribers.camera).forEach(unsubscribe);\n      Object.values(subscribers.screen).forEach(unsubscribe);\n      state.removeAllPublishers();\n      _this.active = false;\n      triggerEvent('endCall');\n      analytics.log(logAction.endCall, logVariation.success);\n    }\n  });\n  Object.defineProperty(this, 'enableLocalAV', {\n    enumerable: true,\n    writable: true,\n    value: function value(id, source, enable) {\n      var method = 'publish' + properCase(source);\n\n      var _state$getPubSub2 = _this.state.getPubSub(),\n          publishers = _state$getPubSub2.publishers;\n\n      publishers.camera[id][method](enable);\n    }\n  });\n  Object.defineProperty(this, 'enableRemoteAV', {\n    enumerable: true,\n    writable: true,\n    value: function value(subscriberId, source, enable) {\n      var method = 'subscribeTo' + properCase(source);\n\n      var _state$getPubSub3 = _this.state.getPubSub(),\n          subscribers = _state$getPubSub3.subscribers;\n\n      var subscriber = subscribers.camera[subscriberId] || subscribers.sip[subscriberId];\n      subscriber[method](enable);\n    }\n  });\n};\n\nexports.default = Communication;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}